# -*- coding: utf-8 -*-
"""
Created on Fri Nov  3 11:08:19 2023

@author: Kirk Ming Yeoh (e0546208@u.nus.edu)

**Note
- This script extracts and processes the macroscale part data from the original .inp file
- It splits each element in the macroscale part into individual parts along with Tie constraints at common boundaries
- It then sets up the data for the first adaptive Direct FE2 model with only the macroscale parts

"""

start_time = time.time()

### Extracting macroscale info from the original .inp file
# Elements and nodes
MacroNodalConnectOld, MacroNodalCoordOld = [],[]
Search1(MacroInp,'*Part, name='+MacroPart,'*Element, type=CPS4',MacroNodalConnectOld,0)
Search1(MacroInp,'*Part, name='+MacroPart,'*Node',MacroNodalCoordOld,1)

Start = MacroInp.index('*Part, name='+str(MacroPart))
End = MacroInp[Start:].index('*End Part')

# Main macroscale part surfaces, need some manipulation
Macro_Surface_List = []    
for i in range(len(Macro_Surface)):
    Mark = 0
    for j in range(Start,Start+End):
        if (MacroInp[j].count(Macro_Surface[i]) != 0) and (MacroInp[j].count('*Surface') != 0):
            Mark = j
            break # Skipping when reach to next surface is handled by the break in the next loop
            
    Temp = []
    Temp.append(MacroInp[Mark])
    for j in range(Mark+1,Start+End):
        if (MacroInp[j] == '') or (MacroInp[j].count("*") != 0):
            break
        Line = ((MacroInp[j].strip('[]')).replace(',',' ')).split()
        Macro_Set.append(Line[0])
        Temp.append(MacroInp[j])
    Macro_Surface_List.append(Temp)

# Main macroscale part sets
Macro_Set_List = []
Macro_Set_Type = []
for i in range(len(Macro_Set)):
    for j in range(Start,Start+End):
        if (MacroInp[j].count(Macro_Set[i]) != 0) and (MacroInp[j].count('set') != 0):
            Mark = j
            if MacroInp[j].count('Nset') != 0:
                Type = 'N'
                break
            elif MacroInp[j].count('Elset') != 0:
                Type = 'El'
                break
            
    Temp = []
    for j in range(Mark+1,Start+End):
        if (MacroInp[j] == '') or (MacroInp[j].count("*") != 0):
            break
        Line = ((MacroInp[j].strip('[]')).replace(',',' ')).split()
        for k in range(len(Line)):
            Temp.append(int(Line[k]))
    Macro_Set_List.append(Temp)
    Macro_Set_Type.append(Type)

### Pre-fill some .inp file data
Heading.append('*Heading')
Heading.append('** Job name: '+JobName+' Model name: '+JobName)
Heading.append('** Generated by: Abaqus/CAE 2017')
Heading.append('*Preprint, echo=NO, model=NO, history=NO, contact=NO')
Heading.append('**')
Macro_Parts.append('** PARTS')
Macro_Parts.append('**')
Insts.append('**')
Insts.append('** ASSEMBLY')
Insts.append('**')
Insts.append('*Assembly, name=Assembly')
Insts.append('**')
Mats.append('*End Assembly')
Mats.append('**')
Mats.append('** MATERIALS')
Mats.append('**')
for i in range(len(RVE_Mat)):
    for j in range(len(RVEMat[i])):
        Mats.append(RVEMat[i][j])
StepsMain.append('** ----------------------------------------------------------------')
StepsMain.append('**')
StepsMain.append('** STEP: Step-1')
StepsMain.append('**')
StepsMain.append('*Step, name=Step-1, nlgeom=%s, inc=10000'%(NLGeom))
StepsMain.append('*Static')
StepsMain.append('0.1, 1., 1e-05, 0.1')
StepsMain.append('**')
StepsMain.append('** BOUNDARY CONDITIONS')
StepsMain.append('**')
Ind = MacroInp.index('** OUTPUT REQUESTS')
for i in range(Ind,len(MacroInp)):
    StepEnd.append(MacroInp[i])
StepEnd[2] = '*Restart, write, frequency=1' # No overlay for now in case we want info from earlier (not last) increment

### Extracting other information from the macroscale input file
for i in range(len(MacroInp)):
    if (MacroInp[i].count('*Part') != 0) and (MacroInp[i] != '*Part, name='+str(MacroPart)):
        for j in range(i,len(MacroInp)):
            Macro_Parts.append(MacroInp[j])
            if MacroInp[j] == '*End Part':
                Macro_Parts.append('**')
                break        
    
    # Other instances
    if (MacroInp[i].count('*Instance') != 0) and (MacroInp[i] != '*Instance, name='+str(MacroPart)+'-1, part='+str(MacroPart)):
        for j in range(i,len(MacroInp)):
            Insts.append(MacroInp[j])
            if MacroInp[j] == '*End Instance':
                Insts.append('**')
                break
            
    # Assembly reference points
    N_Assem = MacroInp.index('** ASSEMBLY')
    if (MacroInp[i] == '*Node') and (i > N_Assem):
        for j in range(i,len(MacroInp)):
            Insts.append(MacroInp[j])
            if (MacroInp[j+1].count('*') != 0): 
                break
            
    # Existing assembly sets 
    if ((MacroInp[i].count('*Nset') != 0) or (MacroInp[i].count('*Elset') != 0)) and (i > N_Assem):
        for j in range(i,len(MacroInp)):
            Macro_Sets.append(MacroInp[j])
            if (MacroInp[j+1].count('*') != 0): 
                break 
            
    # Existing assembly surfaces 
    if ((MacroInp[i].count('*Surface, type=NODE') != 0) or (MacroInp[i].count('*Surface, type=ELEMENT') != 0)) and (i > N_Assem):
        for j in range(i,len(MacroInp)):
            Line = MacroInp[j]
            if Line.count(MacroPart+'-1') != 0:
                Line = Line.replace(MacroPart+'-1.','')
            Surfs.append(Line)
            if ((MacroInp[j+1].count('**') != 0) or (MacroInp[j+1] == '*End Assembly')): 
                break 
    
    # Existing constraints (may need to be modified)
    if MacroInp[i].count('** Constraint') != 0:
        for j in range(i,len(MacroInp)):
            Eqns.append(MacroInp[j])
            if (MacroInp[j+1].count('**') != 0) or (MacroInp[j+1] == '*End Assembly'):
                break
    
    # Interaction properties
    if MacroInp[i].count('** INTERACTION PROPERTIES') != 0:
        for j in range(i,len(MacroInp)):
            IntProps.append(MacroInp[j])
            if (MacroInp[j+1] == '** INTERACTIONS') or (MacroInp[j+1] == '** ----------------------------------------------------------------'):
                break
    
    # Interactions
    if MacroInp[i].count('** INTERACTIONS') != 0:
        for j in range(i,len(MacroInp)):
            Line = MacroInp[j]
            if Line.count(MacroPart+'-1') != 0:
                Line = Line.replace(MacroPart+'-1.','')
            Ints.append(Line)
            if (MacroInp[j+1] == '** ----------------------------------------------------------------'):
                break
        
### Deconstructing macroscale part elements into individual parts 
NodeTieGroups = [[] for x in range(len(MacroNodalCoordOld))]
for i in range(len(MacroNodalConnectOld)):
    Macro_Parts.append('*Part, name=Macro'+str(i+1))
    Macro_Parts.append('*Node')
    Macro_Parts.append('1, '+str(MacroNodalCoordOld[MacroNodalConnectOld[i][0]][0])+', '+str(MacroNodalCoordOld[MacroNodalConnectOld[i][0]][1]))
    Macro_Parts.append('2, '+str(MacroNodalCoordOld[MacroNodalConnectOld[i][1]][0])+', '+str(MacroNodalCoordOld[MacroNodalConnectOld[i][1]][1]))
    Macro_Parts.append('3, '+str(MacroNodalCoordOld[MacroNodalConnectOld[i][2]][0])+', '+str(MacroNodalCoordOld[MacroNodalConnectOld[i][2]][1]))
    Macro_Parts.append('4, '+str(MacroNodalCoordOld[MacroNodalConnectOld[i][3]][0])+', '+str(MacroNodalCoordOld[MacroNodalConnectOld[i][3]][1]))
    Macro_Parts.append('*Element, type=CPS4')
    Macro_Parts.append('1, 1, 2, 3, 4')
    Macro_Parts.append('*Elset, elset=Mat')
    Macro_Parts.append(' 1,')
    Macro_Parts.append('*Orientation, name=Ori-1')
    Macro_Parts.append('1., 0., 0., 0., 1., 0.')
    Macro_Parts.append('3, 0.')    
    Macro_Parts.append('** Section: Solid_ElasticM'+str(i+1))
    Macro_Parts.append('*Solid Section, elset=Mat, orientation=Ori-1, material=Elastic_M'+str(i+1))
    Macro_Parts.append(str(Thickness)+',')
    Macro_Parts.append('*End Part')
    Macro_Parts.append('**')
    
    for j in range(4):
        NodeTieGroups[MacroNodalConnectOld[i][j]].append([i+1,j+1])
        
    Insts.append('*Instance, name=Macro'+str(i+1)+', part=Macro'+str(i+1))
    Insts.append('*End Instance')
    Insts.append('**')
    Mats.append('*Material, name=Elastic_M'+str(i+1))
    Mats.append('*Elastic, type=ENGINEERING CONSTANTS')
    Mats.append(str(MacroProps[0])+', '+str(MacroProps[1])+', '+str(MacroProps[1])+', '+str(MacroProps[2])+', '+str(MacroProps[2])+', '+str(MacroProps[2])+', '+str(MacroProps[3])+', '+str(MacroProps[3]))
    Mats.append(str(MacroProps[3])+', ')

### Sorting nodes that have the same position to Tie them together
for i in range(len(NodeTieGroups)):
    if len(NodeTieGroups[i])>1:
        Macro_Sets.append('*Nset, nset=TieGroupM'+str(i+1)+', instance=Macro'+str(NodeTieGroups[i][0][0]))
        Macro_Sets.append(str(NodeTieGroups[i][0][1]))
        for j in range(1,len(NodeTieGroups[i])):
            Macro_Sets.append('*Nset, nset=TieGroupS'+str(i+1)+', instance=Macro'+str(NodeTieGroups[i][j][0]))
            Macro_Sets.append(str(NodeTieGroups[i][j][1]))
        Surfs.append('*Surface, type=NODE, name=TieGroupM'+str(i+1))
        Surfs.append('TieGroupM'+str(i+1)+', 1.')
        Surfs.append('*Surface, type=NODE, name=TieGroupS'+str(i+1))
        Surfs.append('TieGroupS'+str(i+1)+', 1.')
        Ties.append('** Constraint: Tie-'+str(i+1))
        Ties.append('*Tie, name=Tie-'+str(i+1)+', adjust=yes')
        Ties.append('TieGroupS'+str(i+1)+',TieGroupM'+str(i+1))

### Creating the macroscale sets for split macro in assembly
for i in range(len(Macro_Set_List)):
    if Macro_Set_Type[i] == 'N': # Use master node of NodeTieGroup
        for j in range(len(Macro_Set_List[i])):
            Macro_Sets.append('*Nset, nset='+str(Macro_Set[i])+', instance=Macro'+str(NodeTieGroups[Macro_Set_List[i][j]-1][0][0]))
            Macro_Sets.append(str(NodeTieGroups[Macro_Set_List[i][j]-1][0][1]))
    else:
        for j in range(len(Macro_Set_List[i])): # Use macro element instance
            Macro_Sets.append('*Elset, elset='+str(Macro_Set[i])+', instance=Macro'+str(Macro_Set_List[i][j]))
            Macro_Sets.append('1')
            
### Creating the macroscale surfaces for split macro in assembly
for i in range(len(Macro_Surface)):
    for j in range(len(Macro_Surface_List[i])):
        Surfs.append(Macro_Surface_List[i][j]) #Macro_Surface[Macro_Surface_List[i][j]]

### Handling the macroscale loads, both on the main part and other parts
# Works for boundary conditions, not sure about other types of loads yet
Start = MacroInp.index('** BOUNDARY CONDITIONS')
End = MacroInp.index('** OUTPUT REQUESTS')
MacroLoadSet = []
for i in range(Start+2,End):
    Line = MacroInp[i]
    if Line.count(',') != 0:
        Line = Line.split(',')
        if Line[0].count(MacroPart+'-1') != 0: # == (MacroPart+'-1'):
            Line2 = Line[0].split('.')
            Line[0] = Line2[1]
            if (Line[0] in Macro_Set) and (Line[0] not in MacroLoadSet):
                MacroLoadSet.append(Line[0])
        if (len(Line) == 3) and (Line[1] == Line[2]):
            Line.append(' 0')
        Line3 = Line[0]
        for j in range(1,len(Line)):
            Line3 = Line3 + ',' + Line[j]
        Line = Line3
    StepsMain.append(Line)

# Look for loads asociated with rigid bodies
RigidLoad = []
for i in range(len(StepsMain)):
    if StepsMain[i].count('** Name:') != 0:
        Line = StepsMain[i+2].split(',')
        if Line[0] not in Macro_Set:
            LName = StepsMain[i][9:(len(StepsMain[i])-28)]
            if LName not in RigidLoad:
                for j in range(len(Eqns)):
                    if Eqns[j].count(Line[0]) != 0:
                        Line3 = Eqns[j].split(',')
                        Start = Line3[2].index('=')
                        End = Line3[2].index('.')
                        RName = Line3[2][Start+1:End]
                        break
                RigidLoad.append([LName,Line[0],RName]) # [Load, Set, Rigidbody]                            

# Original macro nodes that are involved in loads applied on macroscale
# Used in AdaptPreLoad when applying deformed configuration
MacroLoadNodes = []
for i in range(len(MacroLoadSet)):  # MacroLoadNodes does not handle nodes in contact set
    TempNodes = []
    Search2(MacroInp,'*Part, name='+MacroPart,'*Nset, nset='+MacroLoadSet[i],TempNodes,0)
    MacroLoadNodes.append(TempNodes)

MacroContactNodes = []
for i in range(len(Macro_Contact_Set)):
    TempNodes = []
    Search2(MacroInp,'*Part, name='+MacroPart,'*Nset, nset='+Macro_Contact_Set[i],TempNodes,0)
    MacroContactNodes.append(TempNodes)
    
Steps = copy.deepcopy(StepsMain)
        
for i in range(len(StepEnd)):
    Steps.append(StepEnd[i])      
    
print('First macroscale only .inp data preparation completed')
Time1 = time.time() - start_time
Time2 = time.time() - start_time0
print('Script time: %ss'%str(Time1))
print('Total time: %ss'%str(Time2))

print>>Time_log,'First macroscale only .inp data preparation completed'
print>>Time_log,'Script time: %ss'%str(Time1)
print>>Time_log,'Total time: %ss'%str(Time2)

















































